C51 COMPILER V9.00   MAIN                                                                  02/19/2019 19:45:12 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*2019蓝桥杯_1数码管和矩阵键盘*/
   2          /*目标实现：数码管显示矩阵键盘获得的数字*/
   3          
   4          #include"main.h"
   5          
   6          sbit KL1=P3^0;sbit KL2=P3^1;sbit KL3=P3^2;sbit KL4=P3^3;
   7          sbit KR1=P4^4;sbit KR2=P4^2;sbit KR3=P3^5;sbit KR4=P3^4;    //矩阵键盘IO定义
   8          
   9          uint t0Cnt; //定时器t0计数
  10          bit isTimer;    //毫秒计数使能
  11          uint keyVal[2]={0,0};  //矩阵键盘值与长短按状态
  12          
  13          uchar ledBuff[8]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};  //数码管显示缓存
  14          uchar ledChar[11]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xfd};    //共阳数码管段码表，10：-
  15          
  16          
  17          //main主函数
  18          void main()
  19          {
  20   1          P2=0xa0;P0=0;P2=0;  //关闭外设
  21   1      
  22   1          TMOD=0;  //开定时器t0并设为模式0 16位自动重载
  23   1          TH0=0xfc;TL0=0x66;  //1ms@11.0592MHz
  24   1          TR0=1;ET0=1;EA=1;   //使能t0和中断
  25   1      
  26   1          isTimer=1;  //毫秒计数使能
  27   1      
  28   1          while(1);
  29   1      }
  30          
  31          
  32          //led数码管扫描
  33          void ledscan()
  34          {
  35   1          static uint i;
  36   1      
  37   1          P2=0xe0;P0=0xff;P2=0;   //消隐
  38   1          P2=0xc0;P0=1<<i;P2=0;   //位选
  39   1          P2=0xe0;P0=ledBuff[i];P2=0; //段码
  40   1      
  41   1          if(i<7)
  42   1              i++;
  43   1          else
  44   1              i=0;
  45   1      }
  46          
  47          
  48          //led数码管设置
  49          void led_set(ulong numShow)
  50          {
  51   1          uint i;
  52   1          uchar buf[8];
  53   1      
  54   1          for(i=7;i>0;i--)
  55   1          {
C51 COMPILER V9.00   MAIN                                                                  02/19/2019 19:45:12 PAGE 2   

  56   2              buf[i]=numShow%10;
  57   2              numShow/=10;
  58   2          }
  59   1      
  60   1          for(i=0;i<8;i++)
  61   1          {
  62   2              if(buf[i]==0)
  63   2              {
  64   3                  ledBuff[i]=0xff;
  65   3              }else
  66   2              {
  67   3                  break;
  68   3              }
  69   2          }
  70   1      
  71   1          for(;i<8;i++)
  72   1          {
  73   2              ledBuff[i]=ledChar[buf[i]];
  74   2          }
  75   1      }
  76          
  77          
  78          //key按键扫描
  79          void keyscan()
  80          {
  81   1          static uchar keyState;  //按键状态机
  82   1          static uint keyLast,keyNow; //本次和上次键值记录
  83   1          static uint keyCnt; //长短按计数
  84   1          uchar kl,kr;    //临时行列键值
  85   1      
  86   1          //键盘行扫描
  87   1          KR1=KR2=KR3=KR4=0;
  88   1          KL1=KL2=KL3=KL4=1;
  89   1          if(KL1==0){kl=1;}
  90   1          else if(KL2==0){kl=2;}
  91   1          else if(KL3==0){kl=3;}
  92   1          else if(KL4==0){kl=4;}
  93   1          else{kl=5;}
  94   1      
  95   1          //键盘列扫描
  96   1          KL1=KL2=KL3=KL4=0;
  97   1          KR1=KR2=KR3=KR4=1;
  98   1          if(KR1==0){kr=1;}
  99   1          else if(KR2==0){kr=2;}
 100   1          else if(KR3==0){kr=3;}
 101   1          else if(KR4==0){kr=4;}
 102   1          else{kr=5;}
 103   1      
 104   1          keyNow=kl*10+kr;
 105   1      
 106   1          //矩阵键盘状态机
 107   1          switch(keyState)
 108   1          {
 109   2              case 0:
 110   2              {
 111   3                  if(keyNow!=keyLast) keyState=1; //检测到按键动作
 112   3              }break;
 113   2              case 1:
 114   2              {
 115   3                  if(keyNow==keyLast) keyState=2;    //消抖按下
 116   3                  else keyState=0;   //认为按键误触
 117   3              }break;
C51 COMPILER V9.00   MAIN                                                                  02/19/2019 19:45:12 PAGE 3   

 118   2              case 2:
 119   2              {
 120   3                  if(keyNow==keyLast) //按键仍然按下
 121   3                  {
 122   4                      keyState=3;
 123   4                  }else   //认为短按
 124   3                  {
 125   4                      keyVal[0]=keyLast;keyVal[1]=0;  //返回短按值
 126   4                      keyState=0;
 127   4                  }
 128   3              }break;
 129   2              case 3:
 130   2              {
 131   3                  if(keyNow==keyLast)
 132   3                  {
 133   4                      if(keyCnt++>100) //长按约1s
 134   4                      {
 135   5                          keyCnt=0;
 136   5                          keyVal[0]=keyLast;keyVal[1]=1;  //返回长按值
 137   5                          keyState=4;
 138   5                      }else
 139   4                      {
 140   5                          keyVal[0]=keyLast;keyVal[1]=0;  //返回短按值
 141   5                          keyState=0;
 142   5                      }
 143   4                  }
 144   3              }break;
 145   2              case 4:
 146   2              {
 147   3                  if(keyNow!=keyLast) keyState=0;
 148   3              }break;
 149   2          }
 150   1          keyLast=keyNow; //键值更新
 151   1      }
 152          
 153          
 154          void t0Server() interrupt 1 //T0:1ms
 155          {
 156   1          static uint keyTimeCnt;
 157   1          static ulong cntCnt;
 158   1      
 159   1          //每10ms矩阵键盘扫描
 160   1          if(keyTimeCnt==10)  
 161   1          {
 162   2              keyTimeCnt=0;
 163   2              keyscan();
 164   2          }else{keyTimeCnt++;}
 165   1      
 166   1          //毫秒表
 167   1          if(isTimer==1)
 168   1          {
 169   2              if(cntCnt==99999999)    
 170   2              {
 171   3                  cntCnt=0;
 172   3              }else
 173   2              {
 174   3                  led_set(keyVal[1]);
 175   3                  cntCnt++;
 176   3              }
 177   2          }
 178   1          
 179   1      
C51 COMPILER V9.00   MAIN                                                                  02/19/2019 19:45:12 PAGE 4   

 180   1          //矩阵键盘响应服务
 181   1          if(keyVal[0]==11 && keyVal[1]==0)
 182   1          {
 183   2              if(isTimer==0){isTimer=1;} 
 184   2              else{isTimer=0;}
 185   2              keyVal[0]=keyVal[1]=0;  //按键复位
 186   2          }
 187   1          if(keyVal[0]==11 && keyVal[1]==1)
 188   1          {
 189   2              cntCnt=0;
 190   2              keyVal[0]=keyVal[1]=0;  //按键复位
 191   2          }
 192   1          
 193   1          ledscan();
 194   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    738    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
